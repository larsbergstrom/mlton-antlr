(* Heavily modified from SML/NJ sources by sweeks@sweeks.com *)

(* ml.grm
 *
 * Copyright 1989,1992 by AT&T Bell Laboratories
 *)

%tokens
    : CHAR of IntInf.t
    | INT of {digits: string,
              negate: bool,
              radix: StringCvt.radix}
    | LONGID of string
    | REAL of string
    | STRING of IntInf.t vector
    | TYVAR of string
    | WORD of {digits: string,
               radix: StringCvt.radix}
    | ABSTYPE | AND | ANDALSO | ARROW | AS | ASTERISK | BAR | CASE | COLON
    | COLONGT | COMMA | DATATYPE | DOTDOTDOT | ELSE | END | EQUALOP
    | EQTYPE | EXCEPTION | DO | DARROW | FN | FUN | FUNCTOR | HANDLE | HASH
    | IF | IN | INCLUDE | INFIX | INFIXR | LBRACE | LBRACKET | LET | LOCAL
    | LPAREN | NONFIX | ORELSE | OF | OP | OPEN | OVERLOAD | RAISE | RBRACE 
    | RBRACKET | REC | RPAREN | SEMICOLON | SHARING | SIG | SIGNATURE | STRUCT
    | STRUCTURE | THEN | TYPE | VAL | WHERE | WHILE | WILD | WITH | WITHTYPE
      (* Extensions *)
    | BUILD_CONST | COMMAND_LINE_CONST | CONST 
    | ADDRESS | EXPORT | IMPORT | SYMBOL 
    | PRIM
    ;

%defs (

fun reg (left, right) = Region.make {left = left, right = right}

fun split (s, c) = String.fields (fn c' => c = c') s

fun translatePos (pos1, pos2) = let
    val map = SourceMap.getMap()
    val {fileName = file, lineNo, colNo} = AntlrStreamPos.sourceLoc map pos1
    val file = case file of SOME x => x | NONE => ""
in
    SourcePos.make({column=colNo, file=file, line=lineNo})
end

fun posToReg (left, right) = let
    val map = SourceMap.getMap()
    val {fileName = file1, lineNo=lineNo1, colNo=colNo1} = AntlrStreamPos.sourceLoc map left
    val {fileName = file2, lineNo=lineNo2, colNo=colNo2} = AntlrStreamPos.sourceLoc map right
    val file1 = case file1 of SOME x => x | NONE => ""
    val file2 = case file2 of SOME x => x | NONE => ""
in
    Region.make({left=SourcePos.make({column=colNo1, file=file1, line=lineNo1}),
		 right=SourcePos.make({column=colNo2, file=file2, line=lineNo2})})
end

fun p (s) = if false then Out.outputl (Out.error, s) else ()

fun error (reg, msg) = (* Control.error (reg, Layout.str msg, Layout.empty) *) ()

open Ast
structure Field = Record.Field
structure Srecord = SortedRecord

structure Type =
   struct
      open Type

      val tuple = Record o Srecord.tuple

      val unit = tuple (Vector.new0 ())

      fun arrow (t1, t2) = Con (Longtycon.arrow, Vector.new2 (t1, t2))
   end

structure DatBind =
   struct
      open DatBind

      fun make (dbs, withtypes, loc) =
         makeRegion (T {datatypes = dbs, withtypes = withtypes}, loc)
   end

structure Pat =
   struct
      open Pat

      fun tuple ps =
         if 1 = Vector.length ps
            then node (Vector.sub (ps, 0))
         else Tuple ps

      val unit = tuple (Vector.new0 ())

      val bogus = unit

      fun makeAs (p1: t, p2: t): node =
         let
            fun err () =
               error (Pat.region p1, "must have variable to left in as pattern")
            fun fixopVar (p : t) =
               case node p of
                  FlatApp ps =>
                     if 1 = Vector.length ps
                        then (case node (Vector.sub (ps, 0)) of
                                 Var {fixop,name} =>
                                    (case Longvid.split name of
                                        ([], vid) =>
                                           SOME (fixop, Vid.toVar vid)
                                      | _ =>
                                           let
                                              val () = err ()
                                           in
                                              SOME (Fixop.None, Var.bogus)
                                           end)
                               | _ => NONE)
                     else NONE
                | _ => NONE
         in
            case fixopVar p1 of
               SOME (fixop, var) =>
                  Layered {fixop = fixop, var = var,
                           constraint = NONE,
                           pat = p2}
             | NONE =>
                  case node p1 of
                     Pat.Constraint (p, t) =>
                        (case fixopVar p of
                            SOME (fixop, var) =>
                               Layered {fixop = fixop, var = var,
                                        constraint = SOME t,
                                        pat = p2}
                          | _ => (err (); bogus))
                   | _ => (err (); bogus)
         end
   end

structure Exp =
   struct
      open Exp

      fun tuple es =
         if 1 = Vector.length es
            then node (Vector.sub (es, 0))
         else Record (Record.tuple es)

      val unit = tuple (Vector.new0 ())
   end

structure Dec =
   struct
      open Dec

      fun sequence (d1: t, d2: t): t =
         makeRegion (case (node d1, node d2) of
                        (SeqDec d1, SeqDec d2) => SeqDec (Vector.concat [d1, d2])
                      | (SeqDec d1, _) =>
                           SeqDec (Vector.concat [d1, Vector.new1 d2])
                      | (_, SeqDec d2) =>
                           SeqDec (Vector.concat [Vector.new1 d1, d2])
                      | _ => SeqDec (Vector.new2 (d1, d2)),
                     Region.append (region d1, region d2))
   end

structure Spec =
   struct
      open Spec

      (* Some of this mess is so that a sharing equation captures as
       * many specs as possible in its scope.
       *)
      fun seq (s: t, s': t): t =
         let
            fun reg s'' = makeRegion (s'', Region.append (region s, region s'))
         in
            case (node s, node s') of
               (Empty, _) => s'
             | (_, Empty) => s
             | (_, Seq (s1, s2)) => reg (Seq (seq (s, s1), s2))
             | (_, Sharing {spec, equations}) =>
                  reg (Sharing {spec = seq (s, spec), equations = equations})
             | _ => reg (Seq (s, s'))
         end

(*      val seq = Trace.trace2 ("Spec.seq", layout, layout, layout) seq *)
   end

fun consTopdec (d, dss) =
   case dss of
      [] => [[d]]
    | ds :: dss => (d :: ds) :: dss

type rule = Pat.t * Exp.t
type clause = {pats : Pat.t vector,
               resultType : Type.t option,
               body : Exp.t}
type clauses = clause vector
type eb = Con.t * EbRhs.t
type db = {tyvars: Tyvar.t vector,
           tycon: Tycon.t,
           cons: (Con.t * Type.t option) vector}

type strdesc = Strid.t * Sigexp.t

type wherespec = {tyvars: Tyvar.t vector,
                  longtycon: Longtycon.t,
                  ty: Type.t}

type typdesc =  {tyvars: Tyvar.t vector,
                 tycon: Tycon.t}

type valdesc = Var.t * Type.t

type exndesc = Con.t * Type.t option

type strbind = {name: Strid.t,
                def: Strexp.t,
                constraint: SigConst.t}

type sigbind = Sigid.t * Sigexp.t

type funbind = {name : Fctid.t,
                arg : FctArg.t,
                result : SigConst.t,
                body : Strexp.t}

type vb = {pat: Pat.t,
           exp: Exp.t}

type rvb = {pat: Pat.t,
            match: Match.t}

fun ensureNonqualified (ss: Symbol.t list, r: Region.t): Symbol.t * Region.t =
   case ss of
      [s] => (s, r)
    | _ => (error (r, "expected nonqualified id")
            ; (Symbol.bogus, r))

);

%header (functor MLParserFun (structure Lex : ANTLR_LEXER
                              structure SourceMap : SOURCE_MAP
                              structure Ast: AST));

program: expsAndTopdecs => (p ("program "); Program.T expsAndTopdecs)
       ;

expsAndTopdecs : (topdec)* => ([SR])
       ;

(*
expsAndTopdecs : (expOrTopDec)* => (SR)
       ;

expOrTopDec: exp SEMICOLON => (Topdec.fromExp exp)
           | topdec => (topdec) 
       ;
*)

topdec : topdecnode => (p ("topdec "); Topdec.makeRegion (topdecnode, posToReg (FULL_SPAN)))
       ;

topdecnode
   : strdec
     => (p ("topdecnode1 "); Topdec.Strdec strdec)
   | SIGNATURE sigbinds
     => (p ("topdecnode2 "); let
         val sigbinds = Vector.fromList sigbinds
         val d = Topdec.Signature sigbinds
      in
         d
      end)
   | FUNCTOR funbinds
     => (p ("topdecnode3 "); Topdec.Functor (Vector.fromList funbinds))
       ;

(*---------------------------------------------------*)
(*                    Structures                     *)
(*---------------------------------------------------*)

strdecs : strdecsnode => (p ("strdecs "); Strdec.makeRegion (strdecsnode, posToReg (FULL_SPAN)))
       ;

strdecsnode : (strdec SEMICOLON?)*  => (p ("strdecsnode1 "); Strdec.Seq SR)
       ;

strdec : strdecnode => (p ("strdec "); Strdec.makeRegion (strdecnode, posToReg (FULL_SPAN)))
       ;

strdecnode
   : STRUCTURE strbinds
     => (p ("strdecnode1 "); let
         val strbinds = Vector.fromList strbinds
         val d = Strdec.Structure strbinds



      in
         d
      end)
   | LOCAL strdecs IN strdecs END  => (p ("strdecnode2 "); Strdec.Local (strdecs1, strdecs2))
   | decnolocal
     => (p ("strdecnode3 "); Strdec.Core (Dec.makeRegion (decnolocal, posToReg (FULL_SPAN))))
       ;

strbind : strid sigconst EQUALOP strexp => (p ("strbind "); {name=strid, def=strexp, constraint=sigconst})
       ;

strbinds : strbind (AND strbind)* => (p ("strbinds "); strbind::SR)
       ;

strexp : strexpnode => (p ("strexp "); Strexp.makeRegion (strexpnode, posToReg (FULL_SPAN)))
       ;

strexpnode
  : strexp2node ( COLON sigexp' (wherespecs)?
                  => (p ("strexpnode1 "); let
                          val strexp2 = Strexp.makeRegion (strexp2node, posToReg (strexp2node_SPAN))
                      in
                          case SR
                           of SOME(ws) => (p ("strexpnode1_some "); Strexp.Constrained
                                               (strexp2,
                                                SigConst.Transparent (
                                                Sigexp.wheree
                                                    (sigexp', ws, posToReg (FULL_SPAN)))))
                            | NONE => (p ("strexpnode1_none "); Strexp.Constrained(strexp2,
                                                          SigConst.Transparent (sigexp')))
                      end)
                | COLONGT sigexp' (wherespecs)?
                  => (p ("strexpnode2 "); let
                          val strexp2 = Strexp.makeRegion (strexp2node, posToReg (strexp2node_SPAN))
                      in
                          case SR
                           of SOME(ws) => (p ("strexpnode2_some "); Strexp.Constrained
                                               (strexp2,
                                                SigConst.Opaque (
                                                Sigexp.wheree
                                                    (sigexp', ws, posToReg (FULL_SPAN)))))
                            | NONE => (p ("strexpnode2_none "); Strexp.Constrained(strexp2,
                                                          SigConst.Opaque (sigexp')))
                      end))? => (case SR
				  of NONE => strexp2node
				   | SOME ans => ans)
       ;

strexp2node
        : longid (arg_fct)?          => (p ("strexp2node1 ");
					 case SR
					  of NONE => Strexp.Var (Longstrid.fromSymbols longid)
					   | SOME arg_fct => Strexp.App (Fctid.fromSymbol (ensureNonqualified longid), arg_fct))
        | STRUCT strdecs END         => (p ("strexp2node2 "); Strexp.Struct strdecs)
        | LET strdecs IN strexp END  => (p ("strexp2node4 "); Strexp.Let (strdecs,strexp))
       ;

arg_fct : LPAREN (strexp RPAREN   => (p ("arg_fct1 "); strexp)
        | strdecs RPAREN  => (p ("arg_fct2 "); Strexp.makeRegion (Strexp.Struct strdecs, posToReg (FULL_SPAN)))) => (SR)
       ;

(*---------------------------------------------------*)
(*                    Signatures                     *)
(*---------------------------------------------------*)

sigexp
  : sigexp' (wherespecs)?
    => (p ("sigexp "); case SR
         of NONE => sigexp'
          | SOME ws =>
                (p ("sigexp_some "); Sigexp.wheree (sigexp', ws, posToReg (FULL_SPAN))))
       ;

wherespecs : wherespecs' => (p ("wherespecs "); Vector.fromList wherespecs')
       ;

wherespecs'
  : WHERE wherespec (              => (p ("wherespecs'1 "); [wherespec])
                    | wherespecs'  => (p ("wherespecs'2 "); wherespec :: wherespecs')
                   |  andspecs     => (p ("wherespecs'3 "); wherespec :: andspecs)) => (SR)
       ;

andspecs
  : AND wherespec (             => (p ("andspecs1 "); [wherespec])
                 | andspecs     => (p ("andspecs2 "); wherespec :: andspecs)
                 | wherespecs'  => (p ("andspecs3 "); wherespec :: wherespecs')) => (SR)
       ;

sigexp' : sigexp'node => (p ("sigexp' "); Sigexp.makeRegion (sigexp'node, posToReg (FULL_SPAN)))
       ;

sigexp'node : sigid                      => (p ("sigexp'node1 "); Sigexp.Var sigid)
            | SIG specs END              => (p ("sigexp'node2 "); Sigexp.Spec specs)
       ;

sigbinds: sigbind (AND sigbind)* => (p ("sigbinds "); (sigbind::SR))
       ;

sigbind : sigid EQUALOP sigexp' (andwherespec)* => (p ("sigbind "); 
                 (sigid, Sigexp.wheree (sigexp', Vector.fromList SR, posToReg FULL_SPAN)))
       ;

wherespec  : TYPE tyvars longtycon EQUALOP ty  => (p ("wherespec "); {tyvars = tyvars,
                                                 longtycon = longtycon,
                                                 ty = ty} : wherespec)
       ;

sigconst :                 => (p ("sigconst1 "); SigConst.None)
         | COLON sigexp    => (p ("sigconst2 "); SigConst.Transparent sigexp)
         | COLONGT sigexp  => (p ("sigconst3 "); SigConst.Opaque sigexp)
       ;

specs  :                   => (p ("specs1 "); Spec.makeRegion (Spec.Empty, Region.bogus))
       | spec (SEMICOLON? spec)* => (p ("specs2 "); 
				     let
					 fun specfold ([spec]) = spec
					   | specfold (x::xs) = Spec.seq(x, specfold xs)
                                           | specfold _ = raise Fail "Cannot happen."
				     in
					 specfold (spec::SR)
				     end)
       ;

spec : specnode => (p ("spec "); Spec.makeRegion (specnode, posToReg (FULL_SPAN)))
       ;

specnode : VAL valdescs         => (p ("specnode1 "); Spec.Val (Vector.fromList valdescs))
         | TYPE (%try typBind         => (p ("specnode3 "); Spec.TypeDefs typBind) 
         | %try typdescs        => (p ("specnode2 "); Spec.Type (Vector.fromList typdescs))) => (SR)
         | EQTYPE typdescs      => (p ("specnode4 "); Spec.Eqtype (Vector.fromList typdescs))
         | DATATYPE datatypeRhsNoWithtype => (p ("specnode5 "); Spec.Datatype datatypeRhsNoWithtype)
         | EXCEPTION exndescs   => (p ("specnode6 "); Spec.Exception (Vector.fromList exndescs))
         | STRUCTURE strdescs   => (p ("specnode7 "); Spec.Structure (Vector.fromList strdescs))
         | INCLUDE (sigexp       => (p ("specnode8 "); Spec.IncludeSigexp sigexp)
         | sigid (sigid)+ (* p. 59 *)
           => (p ("specnode9 "); Spec.IncludeSigids (Vector.fromList (sigid::SR)) )) => (SR)
         | sharespec
           => (p ("specnode10 "); Spec.Sharing {spec = Spec.makeRegion (Spec.Empty, posToReg (FULL_SPAN)),
                          equations = (Vector.new1
                                       (Equation.makeRegion (sharespec, posToReg (FULL_SPAN))))})
       ;
       
sharespec : SHARING (TYPE longtyconeqns => (p ("sharespec1 "); Equation.Type longtyconeqns)
          | longstrideqns      => (p ("sharespec2 "); Equation.Structure longstrideqns)) => (SR)
       ;

longstrideqns : longstrid EQUALOP (longstrid => (p ("longstrideqns1 "); (true, [longstrid,longstrid]))
              | longstrideqns => (p ("longstrideqns2 "); (false, longstrid :: longstrideqns))) =>
		(case SR
		  of (true, [_, l]) => [longstrid, l]
		   | (false, l) => l
		   | _ => raise Fail "Impossible")
       ;

longtyconeqns : longtycon EQUALOP (longtycon => (p ("longtyconeqns1 "); (true, [longtycon,longtycon]))
              | longtyconeqns => (p ("longtyconeqns2 "); (false, longtycon :: longtyconeqns))) => 
		(case SR
		  of (true, [_, l]) => [longtycon, l]
		   | (false, l) => l
		   | _ => raise Fail "Impossible")
       ;

strdesc : strid COLON sigexp' (andwherespec)*  => (p ("strdesc "); (strid, Sigexp.wheree (sigexp', Vector.fromList SR, posToReg (FULL_SPAN))))
       ;

andwherespec : WHERE wherespec
             | AND wherespec
       ;

strdescs : strdesc (AND strdesc)*  => (p ("strdescs "); strdesc::SR)
       ;

typdescs : typdesc (AND typdesc)*  => (p ("typdescs "); typdesc :: SR)
       ;

typdesc : tyvars tycon => (p ("typdesc "); {tyvars = tyvars,
                         tycon = tycon})
       ;
valdescs : valdesc (AND valdesc)*   => (p ("valdescs "); valdesc :: SR)
       ;

valdesc : var COLON ty  => (p ("valdesc "); Con.ensureSpecify (Vid.toCon (Vid.fromVar var))
                         ; (var, ty))
       ;

exndescs : exndesc (AND exndesc)*   => (p ("exndescs "); exndesc :: SR)
       ;

exndesc : con (OF ty)?  => (p ("exndesc "); Con.ensureSpecify con; (con, SR))
       ;

(*---------------------------------------------------*)
(*                     Functors                      *)
(*---------------------------------------------------*)

funbinds : fctid LPAREN fctarg RPAREN sigconst EQUALOP funbinds'
           => (p ("funbinds "); let val (strexp,funbinds) = funbinds'
            in {name = fctid,
                arg = FctArg.makeRegion (fctarg, posToReg (FULL_SPAN)),
                result = sigconst,
                body = strexp}
               :: funbinds
            end)
       ;

funbinds' : strexp (AND funbinds)?  => (p ("funbinds' "); (strexp, case SR of NONE => [] | SOME x => x))
       ;

fctarg : strid COLON sigexp  => (p ("fctarg1 "); FctArg.Structure (strid, sigexp))
       | specs               => (p ("fctarg2 "); FctArg.Spec specs)
       ;

(*---------------------------------------------------*)
(*                   Declarations                    *)
(*---------------------------------------------------*)

       (*
HERE...

Need to support:
1) as many semicolons as they have
2) empty declarations?
3) NOT dec dec --- a semicolon is required for adjacent declarations
   *)

decs : (dec (SEMICOLON?))* => (p ("decs "); case SR
                                of [] => (p ("decs_nil "); Dec.makeRegion (Dec.SeqDec (Vector.new0 ()), posToReg (FULL_SPAN)))
                                 | _ => (p ("decs_some "); let
                                             fun seqFold ([(x,_)]) = x
                                               | seqFold ((x,_)::xs) = Dec.sequence(x, seqFold xs)
                                               | seqFold _ = raise Fail "Cannot happen."
                                         in
                                             seqFold SR
                                         end))
      ;

dec : decnode => (p ("dec "); Dec.makeRegion (decnode, posToReg (FULL_SPAN)))
       ;

decnode : decnolocal              => (p ("decnode1 "); decnolocal) 
        | LOCAL decs IN decs END  => (p ("decnode2 "); Dec.Local (decs1,decs2))
       ;

decnolocal
        : VAL (valbindTop          => (p ("decnolocal1 "); let val (vbs, rvbs) = valbindTop
                                      in
                                          Dec.Val {tyvars = Vector.new0 (), vbs=vbs, rvbs=rvbs}
                                      end)
             | tyvarseq valbindTop  => (p ("decnolocal2 "); let val (vbs, rvbs) = valbindTop
                                       in
                                           Dec.Val {tyvars = tyvarseq, vbs=vbs, rvbs=rvbs}
                                       end)) => (SR)
        | FUN (funs              => (p ("decnolocal3 "); Dec.Fun (Vector.new0 (), Vector.fromList funs))
             | tyvarseq funs     => (p ("decnolocal4 "); Dec.Fun (tyvarseq, Vector.fromList funs))) => (SR)
        | TYPE typBind          => (p ("decnolocal5 "); Dec.Type typBind)
        | DATATYPE datatypeRhs  => (p ("decnolocal6 "); Dec.Datatype datatypeRhs)
        | ABSTYPE datBind WITH decs END   => (p ("decnolocal7 "); Dec.Abstype {datBind = datBind,
                                                        body = decs})
        | EXCEPTION ebs
          => (p ("decnolocal8 "); Dec.Exception (Vector.fromList ebs))
        | OPEN (longstrid)+       => (p ("decnolocal9 "); Dec.Open (Vector.fromList SR))
        | fixity (vid)+           => (p ("decnolocal10 "); Dec.Fix {fixity = fixity,
                                          ops = Vector.fromList SR})
        | OVERLOAD (digit)? var COLON ty AS longvidands
                                => (p ("decnolocal11 "); Dec.Overload (Priority.T SR, 
                                               var,
                                               Vector.new0 (),
                                               ty,
                                               Vector.fromList longvidands))
       ;

valbindTop : valbind => (p ("valbindTop "); let
                         val (vbs, rvbs) = valbind
                      in
                         (Vector.fromList vbs,
                          Vector.fromList rvbs)
                      end)
       ;

valbind : pat EQUALOP exp (AND valbind)?
          => (p ("valbind1 "); let
              val valbindRest = case SR of SOME x => x | NONE => ([], [])
              val (vbs, rvbs) = valbindRest
           in
              ({pat = pat, exp = exp} :: vbs,
               rvbs)
           end)
        | REC rvalbind                 => (p ("valbind2 "); ([], rvalbind))
       ;


rvalbind : REC rvalbind                => (p (" "); rvalbind)
         | pat EQUALOP FN match (AND rvalbind)?
            => (p ("rvalbind2 "); {pat = pat, match = match} :: (case SR of SOME x => x | NONE => []))
       ;

funs    : clausesTop (AND clausesTop)*      => (p ("funs "); clausesTop :: SR)
       ;

clausesTop: clauses => (p ("clausesTop "); Vector.fromList clauses)
       ;

clauses : clause (BAR clause)*    => (p ("clauses "); clause :: SR)
       ;

clause  : apats (COLON ty)? EQUALOP exp  => (p ("clause "); {pats = Vector.fromList apats,
                                          resultType = SR,
                                          body = exp})
       ;

typBind : typBind'
          => (p ("typBind "); let
              val typBind = Vector.fromList typBind'
              val b =
                 TypBind.makeRegion
                 (TypBind.T typBind, posToReg (FULL_SPAN))
           in
              b
           end)
       ;

typBind' : typBind''' (AND typBind''')* => (p ("typbind' "); typBind'''::SR)
       ;

typBind''' : tyvars tycon EQUALOP ty => (p ("typbind' "); {def = ty, tycon = tycon, tyvars = tyvars})
       ;

tyvars  : tyvarseq => (p ("tyvars1 "); tyvarseq)
        |          => (p ("tyvars2 "); Vector.new0 ())
       ;

tyvarseq: tyvar                   => (p ("tyvarseq1 "); Vector.new1 tyvar)
        | LPAREN tyvar_pc RPAREN
          => (p ("tyvarseq2 "); let
              val v = Vector.fromList tyvar_pc
              val () =
                 reportDuplicates
                 (v, {equals = Tyvar.sameName,
                      layout = Tyvar.layout,
                      name = "type variable",
                      region = Tyvar.region,
                      term = fn () => Layout.tuple (Vector.toListMap
                                                    (v, Tyvar.layout))})
           in
              v
           end)
       ;

tyvar_pc: tyvar (COMMA tyvar)* => (p ("tyvar_pc "); tyvar :: SR)
       ;

constrs : constr (BAR constr)*    => (p ("constrs "); constr :: SR)
       ;

constr  : opcon (OF ty)?        => (p ("constr1 "); (opcon, SR))
       ;

opcon   : (OP)? con           => (p ("opcon1 "); con)
       ;

ebs     : eb (AND eb)*      => (p ("ebs "); eb::SR)
       ;

eb      : opcon ebrhs     => (p ("eb "); Con.ensureRedefine opcon; (opcon, ebrhs))
       ;

ebrhs : (ebrhsnode)? => (p ("ebrhs ");
			 case SR
			  of SOME n => EbRhs.makeRegion (n, posToReg (FULL_SPAN))
			   | NONE => EbRhs.makeRegion (EbRhs.Gen NONE, posToReg FULL_SPAN))
       ;

ebrhsnode   : OF ty              => (p ("ebrhsnode2 "); EbRhs.Gen (SOME ty))
            | EQUALOP (longcon    => (p ("ebrhsnode3 "); EbRhs.Def longcon)
            | OP longcon => (p ("ebrhsnode4 "); EbRhs.Def longcon)) => (SR)
       ;

fixity  : INFIX (                => (p ("fixity1 "); Fixity.Infix NONE)
        | digit           => (p ("fixity2 "); Fixity.Infix (SOME digit))) => (SR)
        | INFIXR (                => (p ("fixity3 "); Fixity.Infixr NONE)
        | digit          => (p ("fixity4 "); Fixity.Infixr (SOME digit))) => (SR)
        | NONFIX                => (p ("fixity5 "); Fixity.Nonfix)
       ;

int : INT
   => (p ("int "); let
       val {digits, negate, radix} = INT
    in
       case StringCvt.scanString (fn r => IntInf.scan (radix, r)) digits of
          NONE => Error.bug "parser saw invalid int"
        | SOME i => if negate then ~ i else i
    end)
       ;

word : WORD
   => (p ("word "); let
       val {digits, radix} = WORD
    in
       case StringCvt.scanString (fn r => IntInf.scan (radix, r)) digits of
          NONE => Error.bug "parser saw invalid word"
        | SOME i => i
    end)
       ;

digit : INT
   => (p ("digit "); let
       val {digits, negate, radix} = INT
    in
       if 1 = String.size digits andalso not negate andalso radix = StringCvt.DEC
          then valOf (Int.fromString digits)
       else let
               open Layout
               val _ = 
                  Control.error (posToReg (FULL_SPAN),
                                 str "invalid digit in infix declaration",
                                 empty)
            in
               0
            end
    end)
       ;

datatypeRhs
   : datatypeRhsnode
     => (p ("datatypeRhs "); DatatypeRhs.makeRegion (datatypeRhsnode, posToReg (FULL_SPAN)))
       ;

datatypeRhsNoWithtype
   : datatypeRhsnodeNoWithtype
     => (p ("datatypeRhsNoWithtype "); DatatypeRhs.makeRegion (datatypeRhsnodeNoWithtype, posToReg (FULL_SPAN)))
       ;

datatypeRhsnode
   : %try repl              => (p ("datatypeRhsnode1 "); repl)
   | %try datBind           => (p ("datatypeRhsnode2 "); DatatypeRhs.DatBind datBind)
       ;

datatypeRhsnodeNoWithtype
   : %try repl               => (p ("datatypeRhsnodeNoWithtype1 "); repl)
   | %try datBindNoWithtype  => (p ("datatypeRhsnodeNoWithtype2 "); DatatypeRhs.DatBind datBindNoWithtype)
       ;

repl : tyvars tycon EQUALOP DATATYPE longtycon
       => (p ("repl "); if Vector.isEmpty tyvars
           then ()
        else error (posToReg (FULL_SPAN),
                    "nonempty tyvars in datatype repl")
        ; DatatypeRhs.Repl {lhs = tycon, rhs = longtycon})
       ;

datBind
   : dbs withtypes
     => (p ("datBind "); DatBind.make (dbs, withtypes, posToReg (FULL_SPAN)))
       ;

datBindNoWithtype
   : dbs
     => (p ("datBindNoWithtype "); DatBind.make (dbs, TypBind.empty, posToReg (FULL_SPAN)))
       ;

dbs : dbs' => (p ("dbs "); Vector.fromList dbs')
       ;

dbs' : db (AND db)*  => (p ("dbs' "); db :: SR)
       ;

db : tyvars tycon EQUALOP constrs
     => (p ("db "); {cons = Vector.fromList constrs,
       tycon = tycon,
       tyvars = tyvars})
       ;

withtypes
   :
     => (p ("withtypes1 "); TypBind.empty)
   | WITHTYPE typBind
     => (p ("withtypes2 "); typBind)
       ;

longvidands : longvid  => (p ("longvidands1 "); [longvid])
            | longvid AND longvidands => (p ("longvidands2 "); longvid :: longvidands)
       ;

match : rules           => (p ("match "); Match.makeRegion (Match.T (Vector.fromList rules), posToReg (FULL_SPAN)))
       ;

rules : pat DARROW (%try closedexp BAR rules => (p ("rules1 "); (pat, closedexp)::rules)
      | %try exp => (p ("rules2 "); [(pat, exp)])) => (p ("rules "); (SR))
      ;

elabel  : field EQUALOP exp     => (p ("elabel "); (field,exp))
       ;

elabels : elabel (COMMA elabel)*  => (p ("elabels "); (elabel :: SR))
       ;

exp : expnode => (p ("exp "); Exp.makeRegion (expnode, posToReg (FULL_SPAN)))
       ;

expnode : exp1
        | FN match              => (p ("exp'2 "); Exp.Fn match)
        | CASE exp OF match     => (p ("exp'3 "); Exp.Case (exp, match))
        | WHILE exp DO exp      => (p ("exp'4 "); Exp.While {test = exp1, expr = exp2})
        | IF exp THEN exp ELSE exp => (p ("exp'5 "); Exp.If (exp1, exp2, exp3))
        | RAISE exp             => (p ("exp'6 "); Exp.Raise exp)
       ;

exp1 : app_exp ( COLON ty => (Exp.Constraint (Exp.makeRegion (Exp.FlatApp (Vector.fromList app_exp), posToReg app_exp_SPAN), ty))
               | ANDALSO exp => (Exp.Andalso (Exp.makeRegion (Exp.FlatApp (Vector.fromList app_exp), posToReg app_exp_SPAN), exp))
               | ORELSE exp => (Exp.Orelse (Exp.makeRegion (Exp.FlatApp (Vector.fromList app_exp), posToReg app_exp_SPAN), exp))
               | HANDLE match => (Exp.Handle (Exp.makeRegion (Exp.FlatApp (Vector.fromList app_exp), posToReg app_exp_SPAN), match))
               | (* empty *)  => (Exp.FlatApp (Vector.fromList app_exp))) => (SR)
       ;

closedexp : closedexpnode => (p ("closedexp "); Exp.makeRegion (closedexpnode, posToReg (FULL_SPAN)))
       ;

closedexpnode : closedexp1       => (p ("closedexpnode "); closedexp1)
        | WHILE exp DO closedexp      => (p ("exp'4 "); Exp.While {test = exp, expr = closedexp})
        | IF exp THEN exp ELSE closedexp => (p ("exp'5 "); Exp.If (exp1, exp2, closedexp))
        | RAISE closedexp             => (p ("exp'6 "); Exp.Raise closedexp)
       ;

closedexp1 : app_exp ( COLON ty => (Exp.Constraint (Exp.makeRegion (Exp.FlatApp (Vector.fromList app_exp), posToReg app_exp_SPAN), ty))
               | ANDALSO closedexp => (Exp.Andalso (Exp.makeRegion (Exp.FlatApp (Vector.fromList app_exp), posToReg app_exp_SPAN), closedexp))
               | ORELSE closedexp => (Exp.Orelse (Exp.makeRegion (Exp.FlatApp (Vector.fromList app_exp), posToReg app_exp_SPAN), closedexp))
               | HANDLE match => (Exp.Handle (Exp.makeRegion (Exp.FlatApp (Vector.fromList app_exp), posToReg app_exp_SPAN), match))
               | (* empty *)  => (Exp.FlatApp (Vector.fromList app_exp))) => (SR)
       ;

app_exp : aexp'+
      ;

aexp' : aexp => (p ("aexp'1 "); Exp.makeRegion (aexp, posToReg (FULL_SPAN)))
      | longvid => (p ("aexp'2 "); Exp.makeRegion (Exp.Var {name = longvid,
                                                 fixop = Fixop.None},
                                        posToReg (FULL_SPAN)))
      ;

aexp    : OP longvid            => (p ("aexp1 "); Exp.Var {name = longvid,
                                          fixop = Fixop.Op})
        | const                 => (p ("aexp2 "); Exp.Const const)
        | HASH field            => (p ("aexp3 "); Exp.Selector field)
        | LBRACE elabels RBRACE
          => (p ("aexp4 "); Exp.Record (Record.fromVector (Vector.fromList elabels)))
        | LBRACE RBRACE         => (p ("aexp5 "); Exp.unit)
        | LPAREN RPAREN         => (p ("aexp6 "); Exp.unit)
        | LPAREN expnode ( RPAREN                   => (p ("aexp7 "); expnode)
                     | (SEMICOLON exp)+ RPAREN  => (p ("aexp8 "); Exp.Seq (Vector.fromList ((Exp.makeRegion (expnode, posToReg (expnode_SPAN)))::SR)))
                     | (COMMA exp)+ RPAREN  => (p ("aexp9 "); Exp.tuple (Vector.fromList ((Exp.makeRegion (expnode, posToReg (expnode_SPAN)))::SR)))) => (p ("aexp10 "); SR)
        | LBRACKET (exp_list RBRACKET  => (p ("aexp11 "); Exp.List (Vector.fromList exp_list))
        | RBRACKET           => (p ("aexp12 "); Exp.List (Vector.new0 ()))) => (SR)
        | LET decs IN exp ( (SEMICOLON exp)+ END
                       => (p ("aexp13 "); Exp.Let (decs, Exp.makeRegion (Exp.Seq (Vector.fromList (exp::SR)), posToReg (FULL_SPAN))))
                      | END   => (p ("aexp14 "); Exp.Let (decs, exp)))
          => (p ("aexp15 "); SR)
        | ADDRESS string symattributes COLON ty SEMICOLON
          => (p ("aexp16 "); Exp.Prim (PrimKind.Address {attributes = symattributes,
                                       name = string,
                                       ty = ty}))
        | BUILD_CONST string COLON ty SEMICOLON
          => (p ("aexp17 "); Exp.Prim (PrimKind.BuildConst {name = string, ty = ty}))
        | COMMAND_LINE_CONST string COLON ty EQUALOP constOrBool SEMICOLON
          => (p ("aexp18 "); Exp.Prim (PrimKind.CommandLineConst {name = string,
                                                ty = ty,
                                                value = constOrBool}))
        | CONST string COLON ty SEMICOLON
          => (p ("aexp19 "); Exp.Prim (PrimKind.Const {name = string, ty = ty}))
        | EXPORT string ieattributes COLON ty SEMICOLON
          => (p ("aexp20 "); Exp.Prim (PrimKind.Export {attributes = ieattributes,
                                      name = string,
                                      ty = ty}))
        | IMPORT (string ieattributes COLON ty SEMICOLON
          => (p ("aexp21 "); Exp.Prim (PrimKind.Import {attributes = ieattributes,
                                      name = string,
                                      ty = ty}))
        | ASTERISK ieattributes COLON ty SEMICOLON
          => (p ("aexp22 "); Exp.Prim (PrimKind.IImport {attributes = ieattributes,
                                       ty = ty}))) => (SR)
        | PRIM string COLON ty SEMICOLON
          => (p ("aexp23 "); Exp.Prim (PrimKind.Prim {name = string,
                                    ty = ty}))
        | SYMBOL (string symattributes COLON ty SEMICOLON
          => (p ("aexp24 "); Exp.Prim (PrimKind.Symbol {attributes = symattributes,
                                      name = string,
                                      ty = ty}))
        | ASTERISK COLON ty SEMICOLON
          => (p ("aexp25 "); Exp.Prim (PrimKind.ISymbol {ty = ty}))) => (SR)
       ;

ieattributes
   :
     => (p ("ieattributes1 "); [])
   | id ieattributes
     => (p ("ieattributes2 "); let
             val (sym, _) = id
             val id = Symbol.toString sym
      in
         case id of
            "cdecl" => PrimKind.ImportExportAttribute.Cdecl :: ieattributes
          | "external" => PrimKind.ImportExportAttribute.External :: ieattributes
          | "private" => PrimKind.ImportExportAttribute.Private :: ieattributes
          | "public" => PrimKind.ImportExportAttribute.Public :: ieattributes
          | "stdcall" => PrimKind.ImportExportAttribute.Stdcall :: ieattributes
          | _ => (error (posToReg (FULL_SPAN), concat ["invalid attribute: ", id])
                  ; ieattributes)
      end)
       ;

symattributes
   :
     => (p ("symattributes1 "); [])
   | id symattributes
     => (p ("symattributes2 "); let
             val (sym, _) = id
             val id = Symbol.toString (sym)
      in
         case id of
            "alloc" => PrimKind.SymbolAttribute.Alloc :: symattributes
          | "external" => PrimKind.SymbolAttribute.External :: symattributes
          | "private" => PrimKind.SymbolAttribute.Private :: symattributes
          | "public" => PrimKind.SymbolAttribute.Public :: symattributes
          | _ => (error (posToReg (FULL_SPAN), concat ["invalid attribute: ", id])
                  ; symattributes)
      end)
       ;

exp_list : exp (COMMA exp)*   => (p ("exp_list "); exp :: SR)
       ;

(*---------------------------------------------------*)
(*                     Patterns                      *)
(*---------------------------------------------------*)

pat : patnode' (AS patnode')?    => (p ("pat "); 
        case SR
         of NONE => patnode'
          | SOME p => Pat.makeRegion (Pat.makeAs (patnode', p), posToReg (FULL_SPAN)))
       ;
                           
patnode' : apats (COLON ty)?  => (p ("patnode' "); let
                                      val ap = Pat.makeRegion (Pat.FlatApp (Vector.fromList apats), posToReg (apats_SPAN))
                                  in
                                      case SR
                                       of NONE => ap
                                        | SOME ty => Pat.makeRegion (Pat.Constraint(ap, ty), posToReg (SR_SPAN))
                                  end)
       ;

apats   : (apat)+                  => (p ("apats "); SR)
       ;

apat : apatnode => (p ("apat "); Pat.makeRegion (apatnode, posToReg (FULL_SPAN)))
       ;

apatnode : longvidNoEqual        => (p ("apatnode1 "); Pat.Var {name = longvidNoEqual,
                                           fixop = Fixop.None})
        | OP longvid             => (p ("apatnode2 "); Pat.Var {name = longvid,
                                           fixop = Fixop.Op})
        | const
          => (p ("apatnode3 "); let
              val _ =
                 case Const.node const of
                    Const.Real r =>
                       let
                          open Layout
                       in
                          Control.error
                          (Const.region const,
                           seq [str "real constants are not allowed in patterns: ",
                                Const.layout const],
                           empty)
                       end
                    | _ => (())
           in
              Pat.Const const
           end)
        | WILD                   => (p ("apatnode4 "); Pat.Wild)
        | LPAREN pats RPAREN     => (p ("apatnode5 "); Pat.tuple (Vector.fromList pats))
        | LBRACKET pats RBRACKET => (p ("apatnode6 "); Pat.List (Vector.fromList pats))
        | LBRACE (RBRACE          => (p ("apatnode7 "); Pat.unit)
        | patitems RBRACE
          => (p ("apatnode8 "); let
              val (items, flexible) = patitems
           in
              Pat.Record {flexible = flexible,
                          items = Vector.fromList items}
           end)) => (SR)
       ;

pats : (* empty *)      => (p ("pats1 "); [])
     | pat (COMMA pat)* => (p ("pats2 "); pat::SR)
       ;

patitems : patitem (COMMA patitem)* (COMMA DOTDOTDOT)? => (p ("patitems1 "); (patitem::SR1, (case SR2 of NONE => false | _ => true)))
        | DOTDOTDOT => (p ("patitems2 "); ([], true))
        ;

patitem
   : field EQUALOP pat
     => (p ("patitem1 "); (field, Pat.Item.Field pat))
   | vidNoEqual (COLON ty)? (AS pat)?
     => (p ("patitem2 "); (Field.Symbol (Vid.toSymbol vidNoEqual),
      Pat.Item.Vid (vidNoEqual, SR1, SR2)))
       ;

(*---------------------------------------------------*)
(*                       Types                       *)
(*---------------------------------------------------*)

ty  : ty1 (ARROW ty1)* => (p ("ty "); case SR
                            of [] => ty1
                             | _ => (
			       let
				   (* FIXME: foldArrow has the wrong region *)
				   fun foldArrow ([x]) = x
				     | foldArrow (x::xs) = Type.makeRegion (Type.arrow (x, foldArrow(xs)), posToReg SR_SPAN)
				     | foldArrow ([]) = raise Fail "Invalid fold"
			       in
				   foldArrow (ty1::SR)
			       end))
    ;

ty1 : ty2 (ASTERISK ty2)* => (p ("ty1 "); case SR
                               of [] => (p ("ty1_nil "); Type.makeRegion (ty2, posToReg (FULL_SPAN)))
                                | _ => (p ("ty1_l "); let
                                      val regioned = List.map ((ty2::SR), (fn n => Type.makeRegion (n, posToReg (FULL_SPAN))))
                                  in
                                      Type.makeRegion (Type.tuple (Vector.fromList regioned), posToReg (FULL_SPAN))
                                        end))
    ;

ty2 : ty3 longtycon* => (p ("ty2 "); case longtycon
                          of [] => ty3
                           | _ => let
			   fun tyfold ([x]) = Type.Con (x,
                                                   Vector.new1 (Type.makeRegion (ty3, posToReg (ty3_SPAN))))
                             | tyfold (x::xs) = Type.Con (x, Vector.new1 (Type.makeRegion (tyfold xs, posToReg (FULL_SPAN))))
                             | tyfold ([]) = raise Fail "Invalid tyfold"
                           in
                              tyfold (rev longtycon)
                           end)
    ;

ty3 : tyvar => (p ("ty3_1 "); Type.Var tyvar)
    | LBRACE (RBRACE => (p ("ty3_2 "); Type.unit)
    | tyrow RBRACE => (p ("ty3_3 "); Type.Record (Srecord.fromVector (Vector.fromList tyrow)))) => (SR)
    | longtycon => (p ("ty3_4 "); Type.Con (longtycon, Vector.new0 ()))
    | LPAREN ty (%try (COMMA ty)+ RPAREN longtycon => (p ("ty3_6 "); Type.Con (longtycon, Vector.fromList (ty::SR)))
    | %try RPAREN => (p ("ty3_5 "); Type.node ty)) => (SR)
    ;

tyrow' : field COLON ty => (p ("tyrow' "); (field, ty))
                               ;
tyrow
    : tyrow' (COMMA tyrow')* => (p ("tyrow "); tyrow'::SR)
    ;

(*---------------------------------------------------*)
(*                       Atoms                       *)
(*---------------------------------------------------*)

constOrBool
   : const => (p ("constOrBool1 "); const)
   | id => (p ("constOrBool2 "); let
            fun ok b = Const.makeRegion (Const.Bool b, posToReg (FULL_SPAN))
             val (sym, loc) = id
         in            
            case Symbol.toString sym of
               "false" => ok false
             | "true" => ok true
             | s => (error (loc, concat ["unknown boolean constant: ", s])
                     ; ok false)
         end)
       ;

const   : const'                => (p ("const "); Const.makeRegion
                                     (const', posToReg (FULL_SPAN)))
       ;

const'  : int                   => (p ("const'1 "); Const.Int int)
        | word                  => (p ("const'2 "); Const.Word word)
        | REAL                  => (p ("const'3 "); Const.Real REAL)
        | STRING                => (p ("const'4 "); Const.String STRING)
        | CHAR                  => (p ("const'5 "); Const.Char CHAR)
       ;

string : STRING  => (p ("string "); CharVector.tabulate
                  (Vector.length STRING, fn i =>
                   Char.fromInt (Int.fromIntInf (Vector.sub (STRING, i)))))
       ;

idNoAsterisk : longidNoAsterisk => (p ("idNoAsterisk "); ensureNonqualified longidNoAsterisk)
       ;

id : idNoAsterisk  => (p ("id1 "); idNoAsterisk)
   | ASTERISK      => (p ("id2 "); (Symbol.asterisk, posToReg (FULL_SPAN)))
       ;

idEqual : id      => (p ("idEqual1 "); id)
        | EQUALOP => (p ("idEqual2 "); (Symbol.equal, posToReg (FULL_SPAN)))
       ;

longid
   : longidNoAsterisk => (p ("longid1 "); longidNoAsterisk)
   | ASTERISK  => (p ("longid2 "); ([Symbol.asterisk], posToReg (FULL_SPAN)))
       ;

longidNoAsterisk
   : LONGID
     => (p ("longidNoAsterisk "); let
         val syms = List.map (split (LONGID, #"."), Symbol.fromString)
      in
         (syms, posToReg (FULL_SPAN))
      end)
       ;

longidEqual : longid   => (p ("longidEqual1 "); longid)
            | EQUALOP  => (p ("longidEqual2 "); ([Symbol.equal], posToReg (FULL_SPAN)))
       ;

vid : idEqual                  => (p ("vid "); Vid.fromSymbol idEqual)
       ;
vidNoEqual : id                => (p ("vidNoEqual "); Vid.fromSymbol id)
       ;
var : idEqual                  => (p ("var "); Var.fromSymbol idEqual)
       ;
con : id                       => (p ("con "); Con.fromSymbol id)
       ;
tycon : idNoAsterisk           => (p ("tycon "); Tycon.fromSymbol idNoAsterisk)
       ;
tyvar : TYVAR                  => (p ("tyvar "); let val reg = posToReg (FULL_SPAN)
                                   in
                                       Tyvar.newString (TYVAR, {left=valOf(Region.left reg), right=valOf(Region.right reg)})
                                   end)
       ;
field : id                     => (p ("field1 "); let val (sym,_) = id in Field.Symbol (sym) end)
      | int                    => (p ("field2 "); let
                                   val int =
                                      IntInf.toInt int
                                      handle Exn.Overflow =>
                                         (error (posToReg (FULL_SPAN),
                                                 "field too huge")
                                          ; 0)
                                in
                                   Field.Int
                                   (if int <= 0
                                       then (error (posToReg (FULL_SPAN),
                                                    "nonpositive field")
                                             ; ~1)
                                    else
                                       int - 1)
                                end) (* int - 1 because fields are 0-based *)
       ;

strid : id                     => (p ("strid "); Strid.fromSymbol id)
       ;
sigid : id                     => (p ("sigid "); Sigid.fromSymbol id)
       ;
fctid : id                     => (p ("fctid "); Fctid.fromSymbol id)
       ;

longtycon : longidNoAsterisk => (p ("longtycon "); Longtycon.fromSymbols longidNoAsterisk)
       ;
longvid : longidEqual      => (p ("longvid "); Longvid.fromSymbols longidEqual)
       ;
longvidNoEqual : longid    => (p ("longvidNoEqual "); Longvid.fromSymbols longid)
       ;
longcon : longid           => (p ("longcon "); Longcon.fromSymbols longid)
       ;
longstrid : longid         => (p ("longstrid "); Longstrid.fromSymbols longid)
       ;

